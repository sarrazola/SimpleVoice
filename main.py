#!/usr/bin/env python3
"""
SimpleVoice - Terminal Voice Transcription Tool
Presiona F12 para iniciar/parar grabaci√≥n, transcribe con Whisper y copia al portapapeles
"""

import os
import sys
import time
import threading
import logging
import tempfile
import warnings
from pathlib import Path

# Silenciar warnings de Whisper para mejor UX
warnings.filterwarnings("ignore", message="FP16 is not supported on CPU")
warnings.filterwarnings("ignore", category=UserWarning)

# Configurar logging con muchos detalles
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(sys.stdout)
    ]
)

logger = logging.getLogger(__name__)

try:
    import pyaudio
    import wave
    import whisper
    import pyperclip
    from pynput import keyboard
    import subprocess
    logger.info("‚úÖ Todas las dependencias importadas correctamente")
except ImportError as e:
    logger.error(f"‚ùå Error importando dependencias: {e}")
    logger.error("Instala las dependencias con: pip install -r requirements.txt")
    sys.exit(1)

class SimpleVoiceRecorder:
    def __init__(self):
        self.is_recording = False
        self.sample_rate = 16000  # Whisper prefiere 16kHz
        self.chunk_size = 1024
        self.channels = 1
        self.temp_dir = tempfile.mkdtemp()
        self.whisper_model = None
        self.recording_thread = None
        self.audio_data = []
        self.start_time = None
        
        logger.info("üéôÔ∏è  Inicializando SimpleVoice...")
        logger.info(f"üìÅ Directorio temporal: {self.temp_dir}")
        
        # Inicializar PyAudio
        self.audio = pyaudio.PyAudio()
        logger.info("üé§ PyAudio inicializado")
        
        # Cargar modelo Whisper
        self.load_whisper_model()
        
        logger.info("üöÄ SimpleVoice listo para usar!")
        logger.info("üî• Presiona F12 para iniciar/parar grabaci√≥n")
        logger.info("üìã La transcripci√≥n se copiar√° autom√°ticamente al portapapeles")
        
    def load_whisper_model(self):
        """Cargar modelo Whisper"""
        try:
            logger.info("ü§ñ Cargando modelo Whisper 'turbo'...")
            # Cargar modelo con configuraci√≥n optimizada
            self.whisper_model = whisper.load_model("turbo", device="cpu")
            logger.info("‚úÖ Modelo Whisper cargado exitosamente")
        except Exception as e:
            logger.error(f"‚ùå Error cargando modelo Whisper: {e}")
            sys.exit(1)
    
    def start_recording(self):
        """Iniciar grabaci√≥n de audio"""
        if self.is_recording:
            logger.warning("‚ö†Ô∏è  Ya se est√° grabando")
            return
            
        logger.info("üéµ INICIANDO GRABACI√ìN...")
        print("üé§ Grabando... (presiona F12 para parar)")
        
        # Notificaci√≥n para empezar a hablar
        self.send_notification("üé§ Grabando", "¬°Habla ahora! Presiona F12 para parar", 2)
        
        self.is_recording = True
        self.audio_data = []
        self.start_time = time.time()
        
        # Iniciar grabaci√≥n en hilo separado
        self.recording_thread = threading.Thread(target=self._record_audio)
        self.recording_thread.start()
        
    def stop_recording(self):
        """Parar grabaci√≥n y procesar audio"""
        if not self.is_recording:
            logger.warning("‚ö†Ô∏è  No se est√° grabando")
            return
            
        logger.info("üõë PARANDO GRABACI√ìN...")
        self.is_recording = False
        
        # Calcular tiempo de grabaci√≥n
        if self.start_time:
            duration = time.time() - self.start_time
            print(f"‚èπÔ∏è  Grabaci√≥n terminada ({duration:.1f}s)")
        
        # Notificaci√≥n de procesamiento
        self.send_notification("ü§ñ Procesando", "Transcribiendo audio...", 3)
        
        # Esperar a que termine el hilo de grabaci√≥n
        if self.recording_thread:
            self.recording_thread.join()
            
        # Procesar audio grabado
        if len(self.audio_data) > 0:
            self._process_audio()
        else:
            logger.warning("‚ö†Ô∏è  No hay audio para procesar")
    
    def _record_audio(self):
        """Grabar audio continuamente"""
        try:
            # Configurar stream de audio
            stream = self.audio.open(
                format=pyaudio.paInt16,
                channels=self.channels,
                rate=self.sample_rate,
                input=True,
                frames_per_buffer=self.chunk_size
            )
            
            while self.is_recording:
                try:
                    # Leer chunk de audio
                    data = stream.read(self.chunk_size, exception_on_overflow=False)
                    self.audio_data.append(data)
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è  Error leyendo audio: {e}")
                    break
            
            # Cerrar stream
            stream.stop_stream()
            stream.close()
            
        except Exception as e:
            logger.error(f"‚ùå Error durante grabaci√≥n: {e}")
            self.is_recording = False
    
    def _process_audio(self):
        """Procesar audio grabado con Whisper"""
        try:
            if not self.audio_data:
                logger.warning("‚ö†Ô∏è  No hay datos de audio para procesar")
                return
            
            # Combinar todos los chunks de audio
            audio_bytes = b''.join(self.audio_data)
            duration = len(audio_bytes) / (self.sample_rate * self.channels * 2)  # 2 bytes per sample (paInt16)
            
            # Guardar audio temporal como WAV
            temp_file = os.path.join(self.temp_dir, "temp_audio.wav")
            
            with wave.open(temp_file, 'wb') as wav_file:
                wav_file.setnchannels(self.channels)
                wav_file.setsampwidth(self.audio.get_sample_size(pyaudio.paInt16))
                wav_file.setframerate(self.sample_rate)
                wav_file.writeframes(audio_bytes)
            
            # Transcribir con Whisper
            logger.info("ü§ñ Transcribiendo con Whisper...")
            print("‚è≥ Procesando audio...", end="", flush=True)
            
            # Configuraci√≥n optimizada para mejor rendimiento
            result = self.whisper_model.transcribe(
                temp_file,
                language="es",
                fp16=False,  # Forzar FP32 para evitar warnings
                verbose=False,  # Reducir output verboso
                temperature=0.0,  # M√°s determin√≠stico
                best_of=1,  # Reducir complejidad
                beam_size=1,  # M√°s r√°pido
                patience=1.0,
                length_penalty=1.0,
                suppress_tokens="",
                initial_prompt=None,
                condition_on_previous_text=False,
                compression_ratio_threshold=2.4,
                logprob_threshold=-1.0,
                no_speech_threshold=0.6
            )
            
            print("\r‚úÖ Transcripci√≥n completada!    ")
            transcription = result["text"].strip()
            logger.info(f"üìù Transcripci√≥n: '{transcription}'")
            
            if transcription:
                # Copiar al portapapeles
                pyperclip.copy(transcription)
                logger.info("üìã ‚úÖ Transcripci√≥n copiada al portapapeles")
                
                # Notificaci√≥n de copiado
                self.send_notification("üìã ¬°Listo!", f"Transcripci√≥n copiada: {transcription[:50]}{'...' if len(transcription) > 50 else ''}", 4)
                
                # Mostrar resultado
                print("\n" + "="*50)
                print("üéØ TRANSCRIPCI√ìN COMPLETA:")
                print(f"üìù {transcription}")
                print("üìã Copiado al portapapeles")
                print("="*50 + "\n")
            else:
                logger.warning("‚ö†Ô∏è  No se detect√≥ texto en el audio")
            
            # Limpiar archivo temporal
            os.remove(temp_file)
            logger.info("üßπ Archivo temporal eliminado")
            
        except Exception as e:
            logger.error(f"‚ùå Error procesando audio: {e}")
    
    def toggle_recording(self):
        """Alternar entre iniciar y parar grabaci√≥n"""
        if self.is_recording:
            self.stop_recording()
        else:
            self.start_recording()
    
    def send_notification(self, title, message, timeout=3):
        """Enviar notificaci√≥n del sistema usando osascript nativo de macOS"""
        try:
            # Usar osascript para notificaciones nativas de macOS
            script = f'''
            display notification "{message}" with title "SimpleVoice" subtitle "{title}"
            '''
            subprocess.run(['osascript', '-e', script], capture_output=True, text=True)
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è Error enviando notificaci√≥n: {e}")
    
    def cleanup(self):
        """Limpiar recursos"""
        try:
            if self.audio:
                self.audio.terminate()
                logger.info("üßπ PyAudio terminado")
        except Exception as e:
            logger.error(f"‚ùå Error limpiando recursos: {e}")

def main():
    """Funci√≥n principal"""
    logger.info("üé¨ Iniciando SimpleVoice...")
    
    # Verificar que ffmpeg est√© instalado
    if os.system("ffmpeg -version > /dev/null 2>&1") != 0:
        logger.error("‚ùå ffmpeg no est√° instalado")
        logger.error("Instala ffmpeg: brew install ffmpeg (macOS)")
        sys.exit(1)
    
    # Crear recorder
    recorder = SimpleVoiceRecorder()
    
    # Configurar captura de teclas
    def on_key_press(key):
        try:
            if key == keyboard.Key.f12:
                logger.info("üî• F12 presionado!")
                recorder.toggle_recording()
        except AttributeError:
            # Ignorar teclas especiales que no podemos procesar
            pass
        except Exception as e:
            logger.error(f"‚ùå Error en captura de tecla: {e}")
    
    def on_key_release(key):
        # Manejar liberaci√≥n de teclas para evitar escape sequences
        pass
    
    # Iniciar listener de teclas
    logger.info("‚å®Ô∏è  Iniciando captura de teclas...")
    with keyboard.Listener(on_press=on_key_press, on_release=on_key_release, suppress=False) as listener:
        try:
            print("\n" + "="*60)
            print("üéôÔ∏è  SIMPLE VOICE - TRANSCRIPCI√ìN DE VOZ")
            print("="*60)
            print("üî• Presiona F12 para INICIAR/PARAR grabaci√≥n")
            print("üìã La transcripci√≥n se copiar√° autom√°ticamente al portapapeles")
            print("‚ùå Presiona Ctrl+C para salir")
            print("="*60 + "\n")
            
            listener.join()
            
        except KeyboardInterrupt:
            logger.info("üëã Cerrando SimpleVoice...")
            recorder.cleanup()
            print("\n¬°Hasta la vista! üëã")
            sys.exit(0)

if __name__ == "__main__":
    main() 